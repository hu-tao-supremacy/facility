
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">onepass.app/facility/cmd/helper.go (0.0%)</option>
				
				<option value="file1">onepass.app/facility/cmd/main.go (0.0%)</option>
				
				<option value="file2">onepass.app/facility/internal/database/helper.go (0.0%)</option>
				
				<option value="file3">onepass.app/facility/internal/database/main.go (0.0%)</option>
				
				<option value="file4">onepass.app/facility/internal/helper/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "time"

        "github.com/golang/protobuf/ptypes"
        "github.com/golang/protobuf/ptypes/timestamp"
        _ "github.com/lib/pq"
        account "onepass.app/facility/hts/account"
        common "onepass.app/facility/hts/common"
        facility "onepass.app/facility/hts/facility"
        organizer "onepass.app/facility/hts/organizer"
        participant "onepass.app/facility/hts/participant"
        "onepass.app/facility/internal/helper"
        typing "onepass.app/facility/internal/typing"
)

// hasPermission is mock function for account.hasPermission
func hasPermission(accountClient account.AccountServiceClient, userID int64, organizationID int64, permissionName common.Permission) (bool, typing.CustomError) <span class="cov0" title="0">{
        in := account.HasPermissionRequest{
                OrganizationId: organizationID,
                UserId:         userID,
                PermissionName: permissionName,
        }
        result, err := accountClient.HasPermission(context.Background(), &amp;in)
        if err != nil </span><span class="cov0" title="0">{
                return false, &amp;typing.PermissionError{Type: permissionName}
        }</span>
        <span class="cov0" title="0">return result.IsOk, nil</span>
}

// hasEvent is mock function for organization.hasEvent
func hasEvent(oragnizationClient organizer.OrganizationServiceClient, organizationID int64, userID int64, eventID int64) (bool, typing.CustomError) <span class="cov0" title="0">{
        in := organizer.HasEventReq{
                OrganizationId: organizationID,
                UserId:         userID,
                EventId:        eventID,
        }
        result, err := oragnizationClient.HasEvent(context.Background(), &amp;in)
        if err != nil </span><span class="cov0" title="0">{
                return false, &amp;typing.NotFoundError{Name: "The organization doesn't own event"}
        }</span>
        <span class="cov0" title="0">return result.IsOk, nil</span>
}

// getEvent is mock function for Participant.getEvent
func getEvent(participantClient participant.ParticipantServiceClient, eventID int64) (*common.Event, typing.CustomError) <span class="cov0" title="0">{
        in := participant.GetEventRequest{
                EventId: eventID,
        }
        result, err := participantClient.GetEvent(context.Background(), &amp;in)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;typing.NotFoundError{Name: "The organization doesn't own event"}
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// isAbleToCreateFacilityRequest is function to check if a facility is able to book according to user psermission
func isAbleToCreateFacilityRequest(fs *FacilityServer, in *facility.CreateFacilityRequestRequest) (bool, typing.CustomError) <span class="cov0" title="0">{
        havingPermissionChannel := make(chan bool)
        eventOwnerChannel := make(chan bool)
        overlapTimeChannel := make(chan bool)
        errorChannel := make(chan typing.CustomError)

        go func() </span><span class="cov0" title="0">{
                isTimeOverlap, err := fs.dbs.IsOverlapTime(in.FacilityId, in.Start, in.End, true)
                errorChannel &lt;- err
                overlapTimeChannel &lt;- isTimeOverlap
        }</span>()

        <span class="cov0" title="0">event, err := getEvent(fs.participant, in.EventId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                result, err := hasPermission(fs.account, in.UserId, event.OrganizationId, common.Permission_UPDATE_EVENT)
                if err != nil </span><span class="cov0" title="0">{
                        errorChannel &lt;- err
                        havingPermissionChannel &lt;- false
                        return
                }</span>
                <span class="cov0" title="0">havingPermissionChannel &lt;- result</span>
        }()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                result, err := hasEvent(fs.organizer, in.UserId, event.OrganizationId, in.EventId)
                if err != nil </span><span class="cov0" title="0">{
                        errorChannel &lt;- err
                        eventOwnerChannel &lt;- false
                        return
                }</span>
                <span class="cov0" title="0">eventOwnerChannel &lt;- result</span>
        }()

        <span class="cov0" title="0">isPermission := &lt;-havingPermissionChannel
        isTimeOverlap := &lt;-overlapTimeChannel
        isEventOwner := &lt;-eventOwnerChannel

        close(errorChannel)
        for err := range errorChannel </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">close(havingPermissionChannel)
        close(eventOwnerChannel)
        close(overlapTimeChannel)
        close(errorChannel)

        if !(isPermission &amp;&amp; isEventOwner) </span><span class="cov0" title="0">{
                return false, &amp;typing.PermissionError{Type: common.Permission_UPDATE_EVENT}
        }</span>

        <span class="cov0" title="0">if isTimeOverlap </span><span class="cov0" title="0">{
                return false, &amp;typing.AlreadyExistError{Name: "Facility is booked at that time"}
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// isAbleToApproveFacilityRequest is function to check if a facility is able to be approved according to user psermission
func isAbleToApproveFacilityRequest(fs *FacilityServer, in *facility.ApproveFacilityRequestRequest) (bool, typing.CustomError) <span class="cov0" title="0">{
        facilityRequest, err := fs.dbs.GetFacilityRequest(in.RequestId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">havingPermissionChannel := make(chan bool)
        overlapTimeChannel := make(chan bool)
        errorChannel := make(chan typing.CustomError, 2)

        go func() </span><span class="cov0" title="0">{
                facility, err := fs.dbs.GetFacilityInfo(facilityRequest.FacilityId)
                if err != nil </span><span class="cov0" title="0">{
                        errorChannel &lt;- err
                        havingPermissionChannel &lt;- false
                        return
                }</span>

                <span class="cov0" title="0">result, err := hasPermission(fs.account, in.UserId, facility.OrganizationId, common.Permission_UPDATE_FACILITY)
                if err != nil </span><span class="cov0" title="0">{
                        errorChannel &lt;- err
                        havingPermissionChannel &lt;- false
                        return
                }</span>
                <span class="cov0" title="0">havingPermissionChannel &lt;- result</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                isTimeOverlap, err := fs.dbs.IsOverlapTime(facilityRequest.FacilityId, facilityRequest.Start, facilityRequest.Finish, false)
                if err != nil </span><span class="cov0" title="0">{
                        errorChannel &lt;- err
                        overlapTimeChannel &lt;- true
                        return
                }</span>

                <span class="cov0" title="0">overlapTimeChannel &lt;- isTimeOverlap</span>
        }()

        <span class="cov0" title="0">isPermission := &lt;-havingPermissionChannel
        isTimeOverlap := &lt;-overlapTimeChannel

        close(errorChannel)
        for err := range errorChannel </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">close(overlapTimeChannel)
        close(havingPermissionChannel)

        if !isPermission </span><span class="cov0" title="0">{
                return false, &amp;typing.PermissionError{Type: common.Permission_UPDATE_FACILITY}
        }</span>

        <span class="cov0" title="0">if isTimeOverlap </span><span class="cov0" title="0">{
                return false, &amp;typing.AlreadyExistError{Name: "Facility is booked at that time"}
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// isAbleToRejectFacilityRequest is function to check if a facility is able to be rejected according to user psermission
func isAbleToRejectFacilityRequest(fs *FacilityServer, in *facility.RejectFacilityRequestRequest) (bool, typing.CustomError) <span class="cov0" title="0">{
        facilityRequest, err := fs.dbs.GetFacilityRequest(in.RequestId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">facility, err := fs.dbs.GetFacilityInfo(facilityRequest.FacilityId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">isPermission, err := hasPermission(fs.account, in.UserId, facility.OrganizationId, common.Permission_UPDATE_FACILITY)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if !isPermission </span><span class="cov0" title="0">{
                return false, &amp;typing.PermissionError{Type: common.Permission_UPDATE_FACILITY}
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func handlePermissionChannel(permissionEventChannel &lt;-chan bool, permissionFacilityChannel &lt;-chan bool) (bool, common.Permission, typing.CustomError) <span class="cov0" title="0">{
        var isPermissionEvent bool
        for i := 0; i &lt; 2; i++ </span><span class="cov0" title="0">{
                select </span>{
                case isPermissionEvent := &lt;-permissionEventChannel:<span class="cov0" title="0">
                        if isPermissionEvent </span><span class="cov0" title="0">{
                                return true, 0, nil
                        }</span>

                case isPermissionFacility := &lt;-permissionFacilityChannel:<span class="cov0" title="0">
                        if isPermissionFacility </span><span class="cov0" title="0">{
                                return true, 0, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">if !isPermissionEvent </span><span class="cov0" title="0">{
                return false, common.Permission_UPDATE_EVENT, nil
        }</span>
        <span class="cov0" title="0">return false, common.Permission_UPDATE_FACILITY, nil</span>
}

// isAbleToViewFacilityRequest a function to check whether user can view the targed facility request
func isAbleToViewFacilityRequest(fs *FacilityServer, userID int64, facilityRequest *common.FacilityRequest) (bool, common.Permission, typing.CustomError) <span class="cov0" title="0">{
        facility, err := fs.dbs.GetFacilityInfo(facilityRequest.FacilityId)
        if err != nil </span><span class="cov0" title="0">{
                return false, 0, err
        }</span>

        <span class="cov0" title="0">permissionEventChannel := make(chan bool)
        permissionFacilityChannel := make(chan bool)
        errorChannel := make(chan typing.CustomError)

        go func() </span><span class="cov0" title="0">{
                event, err := getEvent(fs.participant, facilityRequest.EventId)
                if err != nil </span><span class="cov0" title="0">{
                        errorChannel &lt;- err
                        permissionEventChannel &lt;- false
                        return
                }</span>
                <span class="cov0" title="0">result, err := hasPermission(fs.account, userID, event.OrganizationId, common.Permission_UPDATE_EVENT)
                if err != nil </span><span class="cov0" title="0">{
                        errorChannel &lt;- err
                        permissionEventChannel &lt;- false
                        return
                }</span>
                <span class="cov0" title="0">permissionEventChannel &lt;- result</span>
        }()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                result, err := hasPermission(fs.account, userID, facility.OrganizationId, common.Permission_UPDATE_FACILITY)
                if err != nil </span><span class="cov0" title="0">{
                        errorChannel &lt;- err
                        permissionFacilityChannel &lt;- false
                        return
                }</span>
                <span class="cov0" title="0">permissionFacilityChannel &lt;- result</span>
        }()

        <span class="cov0" title="0">result, permission, err := handlePermissionChannel(permissionEventChannel, permissionFacilityChannel)

        close(errorChannel)
        for err := range errorChannel </span><span class="cov0" title="0">{
                return false, 0, err
        }</span>

        <span class="cov0" title="0">return result, permission, err</span>
}

// isAbleToViewFacilityRequestFull a function to check whether user can view the targed facility request
func isAbleToViewFacilityRequestFull(fs *FacilityServer, userID int64, facilityRequestFull *facility.FacilityRequestWithFacilityInfo) (bool, common.Permission, typing.CustomError) <span class="cov0" title="0">{
        event, err := getEvent(fs.participant, facilityRequestFull.EventId)
        for err != nil </span><span class="cov0" title="0">{
                return false, 0, err
        }</span>
        <span class="cov0" title="0">permissionEventChannel := make(chan bool)
        permissionFacilityChannel := make(chan bool)
        errorChannel := make(chan typing.CustomError)

        go func() </span><span class="cov0" title="0">{
                result, err := hasPermission(fs.account, userID, event.OrganizationId, common.Permission_UPDATE_EVENT)
                if err != nil </span><span class="cov0" title="0">{
                        errorChannel &lt;- err
                        permissionEventChannel &lt;- false
                        return
                }</span>
                <span class="cov0" title="0">permissionEventChannel &lt;- result</span>
        }()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                result, err := hasPermission(fs.account, userID, facilityRequestFull.OrganizationId, common.Permission_UPDATE_FACILITY)
                if err != nil </span><span class="cov0" title="0">{
                        errorChannel &lt;- err
                        permissionFacilityChannel &lt;- false
                        return
                }</span>
                <span class="cov0" title="0">permissionFacilityChannel &lt;- result</span>
        }()

        <span class="cov0" title="0">result, permission, err := handlePermissionChannel(permissionEventChannel, permissionFacilityChannel)

        close(errorChannel)
        for err := range errorChannel </span><span class="cov0" title="0">{
                return false, 0, err
        }</span>

        <span class="cov0" title="0">return result, permission, err</span>
}

// isAbleToGetAvailableTimeOfFacility a function to check whether user can check facility availability
func isAbleToGetAvailableTimeOfFacility(startTime time.Time, finishTime time.Time) typing.CustomError <span class="cov0" title="0">{
        if helper.DayDifference(startTime, finishTime)+1 &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;typing.InputError{Name: "Start must be earlier than Finish"}
        }</span>

        <span class="cov0" title="0">now := time.Now()
        if helper.DayDifference(now, finishTime) &gt;= 30 </span><span class="cov0" title="0">{
                return &amp;typing.InputError{Name: "Booking date can only be within 30 days period from today"}
        }</span>

        <span class="cov0" title="0">dayDifference := helper.DayDifference(now, startTime)
        if dayDifference &lt; 0 </span><span class="cov0" title="0">{
                return &amp;typing.InputError{Name: "Booking time must not be in the past"}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createResultEmptyArray is function to create 2D empy boolean array according to input
func createResultEmptyArray(startTime time.Time, finishTime time.Time, operatingHours map[int32]*common.OperatingHour) []*facility.GetAvailableTimeOfFacilityResponse_Day <span class="cov0" title="0">{
        dayDifference := helper.DayDifference(startTime, finishTime) + 1
        result := make([]*facility.GetAvailableTimeOfFacilityResponse_Day, dayDifference)
        var currentDay time.Time
        for i := range result </span><span class="cov0" title="0">{
                currentDay = startTime.AddDate(0, 0, i)
                operationHour := operatingHours[int32(currentDay.Weekday())]
                if operationHour == nil </span><span class="cov0" title="0">{
                        result[i] = &amp;facility.GetAvailableTimeOfFacilityResponse_Day{Items: nil}
                        continue</span>
                }
                <span class="cov0" title="0">startHour := operationHour.StartHour
                finishHour := operationHour.FinishHour
                hour := finishHour - startHour
                avaialbleTime := make([]bool, hour)
                for j := range avaialbleTime </span><span class="cov0" title="0">{
                        avaialbleTime[j] = true
                }</span>
                <span class="cov0" title="0">result[i] = &amp;facility.GetAvailableTimeOfFacilityResponse_Day{Items: avaialbleTime}</span>
        }

        <span class="cov0" title="0">return result</span>
}

// generateFacilityAvailabilityResult is a function to genereate facility request from empty 2D boolean array
func generateFacilityAvailabilityResult(resultArray []*facility.GetAvailableTimeOfFacilityResponse_Day, startTime time.Time, operatingHours map[int32]*common.OperatingHour, facilityRequests []*common.FacilityRequest) *facility.GetAvailableTimeOfFacilityResponse <span class="cov0" title="0">{
        for _, request := range facilityRequests </span><span class="cov0" title="0">{
                requestStartTime, _ := ptypes.Timestamp(request.Start)
                requestFinishTime, _ := ptypes.Timestamp(request.Finish)
                index := requestStartTime.Day() - startTime.Day()
                operatiingHour := operatingHours[int32(requestStartTime.Weekday())]
                if operatiingHour == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">startHour := operatiingHour.StartHour
                requestStartHour := requestStartTime.Hour()
                requestFinishHour := requestFinishTime.Hour()
                for i, item := range resultArray[index].Items </span><span class="cov0" title="0">{
                        currentHour := int(startHour) + i
                        if item &amp;&amp; currentHour &lt;= requestStartHour || currentHour &gt;= requestFinishHour </span><span class="cov0" title="0">{
                                resultArray[index].Items[i] = false
                        }</span>
                }

        }

        <span class="cov0" title="0">return &amp;facility.GetAvailableTimeOfFacilityResponse{Day: resultArray}</span>
}

// getFacilityInfoWithRequests is function to preapare facility info for GetAvailableTimeOfFacility API
func getFacilityInfoWithRequests(fs *FacilityServer, facilityID int64, start *timestamp.Timestamp, end *timestamp.Timestamp) (*FacilityInfoWithRequest, typing.CustomError) <span class="cov0" title="0">{
        errorChannel := make(chan typing.CustomError, 2)
        faicilityInfoChannel := make(chan *common.Facility)
        faiclityRequestsChannel := make(chan []*common.FacilityRequest)

        go func() </span><span class="cov0" title="0">{
                facilityInfo, err := fs.dbs.GetFacilityInfo(facilityID)
                if err != nil </span><span class="cov0" title="0">{
                        errorChannel &lt;- err
                }</span>
                <span class="cov0" title="0">faicilityInfoChannel &lt;- facilityInfo</span>
        }()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                facilityRequests, err := fs.dbs.GetApprovedFacilityRequestList(facilityID, start, end)
                if err != nil </span><span class="cov0" title="0">{
                        errorChannel &lt;- err
                }</span>
                <span class="cov0" title="0">faiclityRequestsChannel &lt;- facilityRequests</span>
        }()

        <span class="cov0" title="0">facilityInfo := &lt;-faicilityInfoChannel
        facilityRequests := &lt;-faiclityRequestsChannel

        close(errorChannel)
        for err := range errorChannel </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">close(faicilityInfoChannel)
        close(faiclityRequestsChannel)

        return &amp;FacilityInfoWithRequest{Info: facilityInfo, Requests: facilityRequests}, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "net"
        "os"
        "time"

        "github.com/golang/protobuf/ptypes"
        empty "github.com/golang/protobuf/ptypes/empty"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        account "onepass.app/facility/hts/account"
        "onepass.app/facility/hts/common"
        facility "onepass.app/facility/hts/facility"
        organizer "onepass.app/facility/hts/organizer"
        participant "onepass.app/facility/hts/participant"
        database "onepass.app/facility/internal/database"
        typing "onepass.app/facility/internal/typing"

        _ "github.com/lib/pq"
)

// FacilityServer is for handling facility endpoint
type FacilityServer struct {
        facility.UnimplementedFacilityServiceServer
        account     account.AccountServiceClient
        participant participant.ParticipantServiceClient
        organizer   organizer.OrganizationServiceClient
        dbs         *database.DataService
}

// GetFacilityList is a function to list all facilities owned by organization
func (fs *FacilityServer) GetFacilityList(ctx context.Context, in *facility.GetFacilityListRequest) (*facility.GetFacilityListResponse, error) <span class="cov0" title="0">{
        list, err := fs.dbs.GetFacilityList(in.OrganizationId)

        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;facility.GetFacilityListResponse{
                Facilities: list,
        }, nil</span>
}

// GetAvailableFacilityList is a function to list all available facilities
func (fs *FacilityServer) GetAvailableFacilityList(ctx context.Context, in *empty.Empty) (*facility.GetAvailableFacilityListResponse, error) <span class="cov0" title="0">{
        list, err := fs.dbs.GetAvailableFacilityList()

        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;facility.GetAvailableFacilityListResponse{
                Facilities: list,
        }, nil</span>
}

// GetFacilityInfo is a function to get facility’s information
func (fs *FacilityServer) GetFacilityInfo(ctx context.Context, in *facility.GetFacilityInfoRequest) (*common.Facility, error) <span class="cov0" title="0">{
        result, err := fs.dbs.GetFacilityInfo(in.FacilityId)

        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// ApproveFacilityRequest is a function to reject facility’s request by id
func (fs *FacilityServer) ApproveFacilityRequest(ctx context.Context, in *facility.ApproveFacilityRequestRequest) (*common.Result, error) <span class="cov0" title="0">{
        isConditionPassed, err := isAbleToApproveFacilityRequest(fs, in)

        if !isConditionPassed || err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">err = fs.dbs.ApproveFacilityRequest(in.RequestId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">description := fmt.Sprintf("Request ID: %d has been aproved", in.RequestId)
        return &amp;common.Result{
                IsOk:        true,
                Description: description,
        }, nil</span>
}

// RejectFacilityRequest is a function to reject facility’s request by id
func (fs *FacilityServer) RejectFacilityRequest(ctx context.Context, in *facility.RejectFacilityRequestRequest) (*common.Result, error) <span class="cov0" title="0">{
        isConditionPassed, err := isAbleToRejectFacilityRequest(fs, in)
        if !isConditionPassed || err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">err = fs.dbs.RejectFacilityRequest(in.RequestId, in.Reason)

        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">description := fmt.Sprintf("Request ID: %d has been rejected", in.RequestId)
        return &amp;common.Result{
                IsOk:        true,
                Description: description,
        }, nil</span>
}

// CreateFacilityRequest is a function to create facility’s request by id
func (fs *FacilityServer) CreateFacilityRequest(ctx context.Context, in *facility.CreateFacilityRequestRequest) (*common.FacilityRequest, error) <span class="cov0" title="0">{
        isConditionPassed, err := isAbleToCreateFacilityRequest(fs, in)

        if !isConditionPassed || err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">result, err := fs.dbs.CreateFacilityRequest(in.EventId, in.FacilityId, in.Start, in.End)

        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// GetFacilityRequestList is a function to get facility request’s of the organization
func (fs *FacilityServer) GetFacilityRequestList(ctx context.Context, in *facility.GetFacilityRequestListRequest) (*facility.GetFacilityRequestListResponse, error) <span class="cov0" title="0">{
        permission := common.Permission_UPDATE_FACILITY
        isPermission, err := hasPermission(fs.account, in.UserId, in.OrganizationId, permission)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">if !isPermission </span><span class="cov0" title="0">{
                return nil, status.Error(codes.PermissionDenied, (&amp;typing.PermissionError{Type: permission}).Error())
        }</span>

        <span class="cov0" title="0">result, err := fs.dbs.GetFacilityRequestList(in.OrganizationId)

        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;facility.GetFacilityRequestListResponse{
                Requests: result,
        }, nil</span>
}

// GetFacilityRequestsListStatus is a function to get facility’s of the event
func (fs *FacilityServer) GetFacilityRequestsListStatus(ctx context.Context, in *facility.GetFacilityRequestsListStatusRequest) (*facility.GetFacilityRequestsListStatusResponse, error) <span class="cov0" title="0">{
        permission := common.Permission_UPDATE_FACILITY
        event, err := getEvent(fs.participant, in.EventId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">isPermission, err := hasPermission(fs.account, in.UserId, event.OrganizationId, permission)

        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>
        <span class="cov0" title="0">if !isPermission </span><span class="cov0" title="0">{
                return nil, status.Error(codes.PermissionDenied, (&amp;typing.PermissionError{Type: permission}).Error())
        }</span>

        <span class="cov0" title="0">result, err := fs.dbs.GetFacilityRequestsListStatus(in.EventId)

        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;facility.GetFacilityRequestsListStatusResponse{
                Requests: result,
        }, nil</span>
}

// GetFacilityRequestStatus is a function to get facility request’s of the event
func (fs *FacilityServer) GetFacilityRequestStatus(ctx context.Context, in *facility.GetFacilityRequestStatusRequest) (*common.FacilityRequest, error) <span class="cov0" title="0">{
        result, err := fs.dbs.GetFacilityRequest(in.RequestId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">isAbleToviewRequest, permission, err := isAbleToViewFacilityRequest(fs, in.UserId, result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">if !isAbleToviewRequest </span><span class="cov0" title="0">{
                return nil, status.Error(codes.PermissionDenied, (&amp;typing.PermissionError{Type: permission}).Error())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// GetFacilityRequestStatusFull is a function to get facility request’s of the event
func (fs *FacilityServer) GetFacilityRequestStatusFull(ctx context.Context, in *facility.GetFacilityRequestStatusFullRequest) (*facility.FacilityRequestWithFacilityInfo, error) <span class="cov0" title="0">{
        result, err := fs.dbs.GetFacilityRequestStatusFull(in.RequestId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">isAbleToviewRequest, permission, err := isAbleToViewFacilityRequestFull(fs, in.UserId, result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">if !isAbleToviewRequest </span><span class="cov0" title="0">{
                return nil, status.Error(codes.PermissionDenied, (&amp;typing.PermissionError{Type: permission}).Error())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// GetAvailableTimeOfFacility is a function to get available of facility will ignore hours and seconds in start/finish input
func (fs *FacilityServer) GetAvailableTimeOfFacility(ctx context.Context, in *facility.GetAvailableTimeOfFacilityRequest) (*facility.GetAvailableTimeOfFacilityResponse, error) <span class="cov0" title="0">{
        startTime, _ := ptypes.Timestamp(in.Start)
        finishTime, _ := ptypes.Timestamp(in.End)
        err := isAbleToGetAvailableTimeOfFacility(startTime, finishTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">facility, err := getFacilityInfoWithRequests(fs, in.FacilityId, in.Start, in.End)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(err.Code(), err.Error())
        }</span>

        <span class="cov0" title="0">operatingHours := map[int32]*common.OperatingHour{}
        for _, operatingHour := range facility.Info.OperatingHours </span><span class="cov0" title="0">{
                operatingHours[int32(operatingHour.Day.Number())] = operatingHour
        }</span>

        <span class="cov0" title="0">emptyResultArray := createResultEmptyArray(startTime, finishTime, operatingHours)
        return generateFacilityAvailabilityResult(emptyResultArray, startTime, operatingHours, facility.Requests), nil</span>
}

func (fs *FacilityServer) connectToGRPCClients() <span class="cov0" title="0">{
        accountPath := os.Getenv("HTS_SVC_ACCOUNT")
        participantPath := os.Getenv("HTS_SVC_PARTICIPANT")
        organizerPart := os.Getenv("HTS_SVC_ORGANIZER")

        // Disable transport security is intentional
        opts := []grpc.DialOption{grpc.WithInsecure()}
        const deadlineSeconds = 5
        timeout := time.Duration(deadlineSeconds) * time.Second

        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        connAccount, dialError := grpc.DialContext(ctx, accountPath, opts...)
        if dialError != nil </span><span class="cov0" title="0">{
                panic(dialError)</span>
        }
        <span class="cov0" title="0">accountClient := account.NewAccountServiceClient(connAccount)
        fs.account = accountClient

        ctx, cancel = context.WithTimeout(context.Background(), timeout)
        defer cancel()
        connParticipant, dialError := grpc.DialContext(ctx, participantPath, opts...)
        if dialError != nil </span><span class="cov0" title="0">{
                panic(dialError)</span>
        }
        <span class="cov0" title="0">participantClient := participant.NewParticipantServiceClient(connParticipant)
        fs.participant = participantClient

        ctx, cancel = context.WithTimeout(context.Background(), timeout)
        defer cancel()
        connOrganizer, dialError := grpc.DialContext(ctx, organizerPart, opts...)
        if dialError != nil </span><span class="cov0" title="0">{
                panic(dialError)</span>
        }
        <span class="cov0" title="0">organizerClient := organizer.NewOrganizationServiceClient(connOrganizer)
        fs.organizer = organizerClient</span>
}

func main() <span class="cov0" title="0">{
        port := os.Getenv("GRPC_PORT")
        lis, err := net.Listen("tcp", ":"+port)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to listen: %v", err)
        }</span>
        <span class="cov0" title="0">s := grpc.NewServer()

        facilityServer := &amp;FacilityServer{}

        db := &amp;database.DataService{}
        db.ConnectToDB()
        facilityServer.dbs = db

        facilityServer.connectToGRPCClients()
        facility.RegisterFacilityServiceServer(s, facilityServer)
        if err := s.Serve(lis); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to serve: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "encoding/json"
        "time"

        "github.com/golang/protobuf/ptypes/wrappers"
        "github.com/jmoiron/sqlx/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/protobuf/types/known/timestamppb"

        common "onepass.app/facility/hts/common"
        facility "onepass.app/facility/hts/facility"
        "onepass.app/facility/internal/helper"
        model "onepass.app/facility/internal/model"
        typing "onepass.app/facility/internal/typing"
)

func convertOperatingHoursModelToProto(operatingHours types.JSONText) ([]*common.OperatingHour, typing.CustomError) <span class="cov0" title="0">{
        var message []*model.OperatingHour

        if err := json.Unmarshal(operatingHours, &amp;message); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;typing.DatabaseError{StatusCode: codes.DataLoss, Err: err}
        }</span>

        <span class="cov0" title="0">result := make([]*common.OperatingHour, len(message))
        for i, OperatingHour := range message </span><span class="cov0" title="0">{
                result[i] = &amp;common.OperatingHour{
                        Day:        common.DayOfWeek(common.DayOfWeek_value[OperatingHour.Day]),
                        StartHour:  OperatingHour.StartHour,
                        FinishHour: OperatingHour.FinishHour,
                }
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func convertFacilityModelToProto(data *model.Facility) (*common.Facility, typing.CustomError) <span class="cov0" title="0">{
        OperatingHours, err := convertOperatingHoursModelToProto(data.OperatingHours)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;common.Facility{
                Id:             data.ID,
                OrganizationId: data.OrganizationID,
                Name:           data.Name,
                Latitude:       data.Latitude,
                Longitude:      data.Longitude,
                OperatingHours: OperatingHours,
                Description:    data.Description,
        }, nil</span>
}

func convertFacilityRequestModelToProto(data *model.FacilityRequest) *common.FacilityRequest <span class="cov0" title="0">{
        var rejectReason *wrappers.StringValue
        if data.RejectReason.Valid </span><span class="cov0" title="0">{
                rejectReason = &amp;wrappers.StringValue{Value: data.RejectReason.String}
        }</span>
        <span class="cov0" title="0">return &amp;common.FacilityRequest{
                Id:           data.ID,
                EventId:      data.EventID,
                FacilityId:   data.FacilityID,
                Status:       common.Status(common.Status_value[data.Status]),
                RejectReason: rejectReason,
                Start:        timestamppb.New(data.Start),
                Finish:       timestamppb.New(data.Finish),
        }</span>
}

func convertFacilityRequestWithInfoModelToProto(data *model.FacilityRequestWithInfo) (*facility.FacilityRequestWithFacilityInfo, typing.CustomError) <span class="cov0" title="0">{
        var rejectReason *wrappers.StringValue
        if data.RejectReason.Valid </span><span class="cov0" title="0">{
                rejectReason = &amp;wrappers.StringValue{Value: data.RejectReason.String}
        }</span>

        <span class="cov0" title="0">OperatingHours, err := convertOperatingHoursModelToProto(data.OperatingHours)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;facility.FacilityRequestWithFacilityInfo{
                Id:             data.ID,
                EventId:        data.EventID,
                FacilityId:     data.FacilityID,
                Status:         common.Status(common.Status_value[data.Status]),
                RejectReason:   rejectReason,
                Start:          timestamppb.New(data.Start),
                Finish:         timestamppb.New(data.Finish),
                OrganizationId: data.OrganizationID,
                FacilityName:   data.FacilityName,
                Latitude:       data.Latitude,
                Longitude:      data.Longitude,
                OperatingHours: OperatingHours,
                Description:    data.Description,
        }, nil</span>
}

func checkDateInput(start time.Time, finish time.Time, operatingHours []*common.OperatingHour) typing.CustomError <span class="cov0" title="0">{
        if helper.DayDifference(start, finish) != 0 </span><span class="cov0" title="0">{
                return &amp;typing.InputError{Name: "Start and Finish must be the same day"}
        }</span>

        <span class="cov0" title="0">now := time.Now()
        dayDifferenceFromNow := helper.DayDifference(now, start)
        if dayDifferenceFromNow &gt;= 30 </span><span class="cov0" title="0">{
                return &amp;typing.InputError{Name: "Booking date can only be within 30 days period from today"}
        }</span>

        <span class="cov0" title="0">HourStart, MinuteStart, secondStart := start.Clock()
        HourFinish, MinuteFinish, secondFinish := finish.Clock()

        if dayDifferenceFromNow &lt; 0 || (dayDifferenceFromNow == 0 &amp;&amp; HourStart &lt; now.Hour()) </span><span class="cov0" title="0">{
                return &amp;typing.InputError{Name: "Booking time must not be in the past"}
        }</span>
        <span class="cov0" title="0">if MinuteStart != 0 || secondStart != 0 || MinuteFinish != 0 || secondFinish != 0 </span><span class="cov0" title="0">{
                return &amp;typing.InputError{Name: "Minutes and seconds must be 0"}
        }</span>

        <span class="cov0" title="0">if HourStart &gt; HourFinish </span><span class="cov0" title="0">{
                return &amp;typing.InputError{Name: "Start must be earlier than Finish"}
        }</span>

        <span class="cov0" title="0">weekDayStart := start.Weekday()
        var operatingHour *common.OperatingHour
        for _, value := range operatingHours </span><span class="cov0" title="0">{
                day := int(value.Day.Number())
                if day == int(weekDayStart) </span><span class="cov0" title="0">{
                        operatingHour = value
                }</span>
        }
        <span class="cov0" title="0">if operatingHour == nil </span><span class="cov0" title="0">{
                return &amp;typing.InputError{Name: "Not in operatingHours"}
        }</span>

        <span class="cov0" title="0">isStartAfterOpening := int(operatingHour.StartHour) &lt;= HourStart
        isFinishBeforeClose := HourFinish &lt;= int(operatingHour.FinishHour)
        if !isStartAfterOpening || !isFinishBeforeClose </span><span class="cov0" title="0">{
                return &amp;typing.InputError{Name: "Not in operatingHours"}
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "log"
        "os"

        "github.com/golang/protobuf/ptypes"
        "github.com/jmoiron/sqlx/reflectx"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/timestamppb"
        "google.golang.org/protobuf/types/known/wrapperspb"

        common "onepass.app/facility/hts/common"
        facility "onepass.app/facility/hts/facility"
        "onepass.app/facility/internal/helper"
        model "onepass.app/facility/internal/model"
        typing "onepass.app/facility/internal/typing"

        "github.com/iancoleman/strcase"
        "github.com/jmoiron/sqlx"
)

// DataService is for handling data layer
type DataService struct {
        SQL *sqlx.DB
}

const queryForRequestFacilityWithFacilty = `
SELECT 
r.*,
f.organization_id, 
f.name as facility_name, 
f.latitude, 
f.longitude, 
f.organization_id, 
f.operating_hours,
f.description 
FROM facility_request as r
INNER JOIN facility as f
ON f.id = r.facility_id `

// GetFacilityList is a function to get facility list owned by the organization from database
func (dbs *DataService) GetFacilityList(organizationID int64) ([]*common.Facility, typing.CustomError) <span class="cov0" title="0">{
        var facilities []*model.Facility
        query := `
        SELECT * 
        FROM facility 
        WHERE facility.organization_id = ?;`

        query = dbs.SQL.Rebind(query)
        if err := dbs.SQL.Select(&amp;facilities, query, organizationID); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;typing.DatabaseError{
                        Err:        err,
                        StatusCode: codes.Internal,
                }
        }</span>
        <span class="cov0" title="0">result := make([]*common.Facility, len(facilities))
        for i, item := range facilities </span><span class="cov0" title="0">{
                value, err := convertFacilityModelToProto(item)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result[i] = value</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// GetAvailableFacilityList is a function to list all available facilities
func (dbs *DataService) GetAvailableFacilityList() ([]*common.Facility, typing.CustomError) <span class="cov0" title="0">{
        var facilities []*model.Facility
        query := `
        SELECT * 
        FROM facility`

        if err := dbs.SQL.Select(&amp;facilities, query); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;typing.DatabaseError{
                        Err:        err,
                        StatusCode: codes.Internal,
                }
        }</span>

        <span class="cov0" title="0">result := make([]*common.Facility, len(facilities))
        for i, item := range facilities </span><span class="cov0" title="0">{
                value, err := convertFacilityModelToProto(item)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result[i] = value</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// GetFacilityInfo is a function to get facility’s information by id
func (dbs *DataService) GetFacilityInfo(facilityID int64) (*common.Facility, typing.CustomError) <span class="cov0" title="0">{
        var _facility model.Facility
        query := `
        SELECT * 
        FROM facility 
        WHERE facility.id = ?`
        query = dbs.SQL.Rebind(query)
        err := dbs.SQL.Get(&amp;_facility, query, facilityID)

        switch </span>{
        case err == sql.ErrNoRows:<span class="cov0" title="0">
                return nil, &amp;typing.DatabaseError{
                        Err:        &amp;typing.NotFoundError{Name: "facility"},
                        StatusCode: codes.NotFound,
                }</span>
        case err != nil:<span class="cov0" title="0">
                return nil, &amp;typing.DatabaseError{
                        Err:        err,
                        StatusCode: codes.Internal,
                }</span>
        default:<span class="cov0" title="0">
                return convertFacilityModelToProto(&amp;_facility)</span>
        }
}

func (dbs *DataService) updateFacilityRequest(requestID int64, status common.Status, reason *wrapperspb.StringValue) typing.CustomError <span class="cov0" title="0">{
        var queryReason string
        if reason != nil </span><span class="cov0" title="0">{
                queryReason = ", reject_reason=:reason "
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
        UPDATE facility_request 
        SET status=:status%s 
        WHERE facility_request.id = :id`,
                queryReason)
        result, err := dbs.SQL.NamedExec(query, map[string]interface{}{
                "id":     requestID,
                "status": status.String(),
                "reason": reason.GetValue(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return &amp;typing.DatabaseError{
                        Err:        err,
                        StatusCode: codes.Internal,
                }
        }</span>

        <span class="cov0" title="0">count, err := result.RowsAffected()
        switch </span>{
        case err != nil:<span class="cov0" title="0">
                return &amp;typing.DatabaseError{
                        Err:        err,
                        StatusCode: codes.Internal,
                }</span>
        case count != 1:<span class="cov0" title="0">
                return &amp;typing.DatabaseError{
                        Err:        &amp;typing.NotFoundError{Name: "FacilityRequest"},
                        StatusCode: codes.NotFound,
                }</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// RejectFacilityRequest is a function to reject facility’s request by id
func (dbs *DataService) RejectFacilityRequest(requestID int64, reason *wrapperspb.StringValue) typing.CustomError <span class="cov0" title="0">{
        return dbs.updateFacilityRequest(requestID, common.Status_REJECTED, reason)
}</span>

// ApproveFacilityRequest is a function to approve facility request
func (dbs *DataService) ApproveFacilityRequest(requestID int64) typing.CustomError <span class="cov0" title="0">{
        return dbs.updateFacilityRequest(requestID, common.Status_APPROVED, nil)
}</span>

// CreateFacilityRequest is a function to create facilityRequest
func (dbs *DataService) CreateFacilityRequest(eventID int64, facilityID int64, start *timestamppb.Timestamp, finish *timestamppb.Timestamp) (*common.FacilityRequest, typing.CustomError) <span class="cov0" title="0">{
        var id int64
        query := `
        INSERT INTO facility_request (event_id, facility_id, status, start, finish) 
        VALUES (:event_id, :facility_id, :status, :start, :finish) 
        RETURNING id`
        startTime, _ := ptypes.Timestamp(start)
        finishTime, _ := ptypes.Timestamp(finish)
        rows, err := dbs.SQL.NamedQuery(query, map[string]interface{}{
                "event_id":    eventID,
                "facility_id": facilityID,
                "status":      "PENDING",
                "start":       startTime,
                "finish":      finishTime,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;typing.DatabaseError{
                        Err:        err,
                        StatusCode: codes.Internal,
                }
        }</span>
        <span class="cov0" title="0">if rows.Next() </span><span class="cov0" title="0">{
                if err := rows.Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;typing.DatabaseError{
                                Err:        err,
                                StatusCode: codes.Internal,
                        }
                }</span>
        }

        <span class="cov0" title="0">result := common.FacilityRequest{
                Id:         id,
                EventId:    eventID,
                FacilityId: facilityID,
                Status:     common.Status_PENDING,
                Start:      start,
                Finish:     finish,
        }
        return &amp;result, nil</span>
}

// IsOverlapTime is function to check whether time is overlap with already booked facility
func (dbs *DataService) IsOverlapTime(facilityID int64, start *timestamppb.Timestamp, finish *timestamppb.Timestamp, checkTimeIntegrity bool) (bool, typing.CustomError) <span class="cov0" title="0">{
        facility, facilityNotFoundError := dbs.GetFacilityInfo(facilityID)
        if facilityNotFoundError != nil </span><span class="cov0" title="0">{
                return false, facilityNotFoundError
        }</span>

        <span class="cov0" title="0">var count int64
        startTime, _ := ptypes.Timestamp(start)
        finishTime, _ := ptypes.Timestamp(finish)
        if checkTimeIntegrity </span><span class="cov0" title="0">{
                inputError := checkDateInput(startTime, finishTime, facility.OperatingHours)
                if inputError != nil </span><span class="cov0" title="0">{
                        return false, inputError
                }</span>
        }

        <span class="cov0" title="0">layoutTime := "2006-01-02 15:04:05"
        startTimeText := startTime.Format(layoutTime)
        finishTimeText := finishTime.Format(layoutTime)

        query := `
        SELECT COUNT(*) 
        FROM facility_request 
        WHERE ((? &gt;= start AND ? &lt; finish) OR (? &gt; start AND ? &lt;= finish)) 
        AND facility_id = ? 
        AND status='APPROVED' 
        LIMIT 1;`
        query = dbs.SQL.Rebind(query)
        if err := dbs.SQL.Get(&amp;count, query, startTimeText, startTimeText, finishTimeText, finishTimeText, facilityID); err != nil </span><span class="cov0" title="0">{
                return false, &amp;typing.DatabaseError{
                        Err:        err,
                        StatusCode: codes.Internal,
                }
        }</span>

        <span class="cov0" title="0">return count != 0, nil</span>
}

// GetFacilityRequestStatusFull is function to get facilityR request full by id
func (dbs *DataService) GetFacilityRequestStatusFull(requestID int64) (*facility.FacilityRequestWithFacilityInfo, typing.CustomError) <span class="cov0" title="0">{
        var facilityRequest model.FacilityRequestWithInfo

        query := queryForRequestFacilityWithFacilty + `
        WHERE r.id=?
        LIMIT 1;`
        query = dbs.SQL.Rebind(query)
        err := dbs.SQL.Get(&amp;facilityRequest, query, requestID)

        switch </span>{
        case err == sql.ErrNoRows:<span class="cov0" title="0">
                return nil, &amp;typing.DatabaseError{
                        Err:        &amp;typing.NotFoundError{Name: "facility"},
                        StatusCode: codes.NotFound,
                }</span>
        case err != nil:<span class="cov0" title="0">
                return nil, &amp;typing.DatabaseError{
                        Err:        err,
                        StatusCode: codes.Internal,
                }</span>
        default:<span class="cov0" title="0">
                return convertFacilityRequestWithInfoModelToProto(&amp;facilityRequest)</span>
        }
}

// GetFacilityRequest is function to get facility request by id
func (dbs *DataService) GetFacilityRequest(requestID int64) (*common.FacilityRequest, typing.CustomError) <span class="cov0" title="0">{
        var facilityRequest model.FacilityRequest

        query := `
        SELECT * 
        FROM facility_request 
        WHERE id=?
        LIMIT 1;`
        query = dbs.SQL.Rebind(query)
        err := dbs.SQL.Get(&amp;facilityRequest, query, requestID)

        switch </span>{
        case err == sql.ErrNoRows:<span class="cov0" title="0">
                return nil, &amp;typing.DatabaseError{
                        Err:        &amp;typing.NotFoundError{Name: "facility"},
                        StatusCode: codes.NotFound,
                }</span>
        case err != nil:<span class="cov0" title="0">
                return nil, &amp;typing.DatabaseError{
                        Err:        err,
                        StatusCode: codes.Internal,
                }</span>
        default:<span class="cov0" title="0">
                return convertFacilityRequestModelToProto(&amp;facilityRequest), nil</span>
        }
}

func (dbs *DataService) getFacilityRequestWithFacilityInfoList(condition string, params ...interface{}) ([]*facility.FacilityRequestWithFacilityInfo, typing.CustomError) <span class="cov0" title="0">{
        var facilities []*model.FacilityRequestWithInfo

        query := queryForRequestFacilityWithFacilty + condition
        query = dbs.SQL.Rebind(query)
        if err := dbs.SQL.Select(&amp;facilities, query, params...); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;typing.DatabaseError{
                        Err:        err,
                        StatusCode: codes.Internal,
                }
        }</span>
        <span class="cov0" title="0">result := make([]*facility.FacilityRequestWithFacilityInfo, len(facilities))
        for i, item := range facilities </span><span class="cov0" title="0">{
                value, err := convertFacilityRequestWithInfoModelToProto(item)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result[i] = value</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// GetFacilityRequestList is a function to get facilityrequest list owned by the organization from database
func (dbs *DataService) GetFacilityRequestList(organizationID int64) ([]*facility.FacilityRequestWithFacilityInfo, typing.CustomError) <span class="cov0" title="0">{
        return dbs.getFacilityRequestWithFacilityInfoList(`WHERE organization_id = ?;`, organizationID)
}</span>

// GetFacilityRequestsListStatus is a function to get facilityrequest list of the event from database
func (dbs *DataService) GetFacilityRequestsListStatus(eventID int64) ([]*facility.FacilityRequestWithFacilityInfo, typing.CustomError) <span class="cov0" title="0">{
        return dbs.getFacilityRequestWithFacilityInfoList(`WHERE event_id = ?;`, eventID)
}</span>

// GetApprovedFacilityRequestList is a function to get approved facilityRequestList by facility ID
func (dbs *DataService) GetApprovedFacilityRequestList(facilityID int64, start *timestamppb.Timestamp, finish *timestamppb.Timestamp) ([]*common.FacilityRequest, typing.CustomError) <span class="cov0" title="0">{
        var facilitieRequests []*model.FacilityRequest
        query := `
        SELECT * 
        FROM facility_request
        WHERE facility_id = ?
        AND start BETWEEN ? AND ?
        AND status = 'APPROVED';`
        query = dbs.SQL.Rebind(query)

        layoutTime := "2006-01-02"
        startTimeText := helper.TimeStampToText(start, layoutTime)
        finishTimeText := helper.TimeStampToText(finish, layoutTime)

        if err := dbs.SQL.Select(&amp;facilitieRequests, query, facilityID, startTimeText, finishTimeText); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;typing.DatabaseError{
                        Err:        err,
                        StatusCode: codes.Internal,
                }
        }</span>
        <span class="cov0" title="0">result := make([]*common.FacilityRequest, len(facilitieRequests))
        for i, item := range facilitieRequests </span><span class="cov0" title="0">{
                value := convertFacilityRequestModelToProto(item)
                result[i] = value
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (dbs *DataService) ping() (string, error) <span class="cov0" title="0">{
        var version string

        if err := dbs.SQL.Get(&amp;version, "SELECT VERSION();"); err != nil </span><span class="cov0" title="0">{
                return version, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov0" title="0">return version, nil</span>
}

// ConnectToDB is a function to connect to DB and setup sqlx config
func (dbs *DataService) ConnectToDB() <span class="cov0" title="0">{
        host := os.Getenv("POSTGRES_HOST")
        user := os.Getenv("POSTGRES_USER")
        password := os.Getenv("POSTGRES_PASSWORD")
        database := os.Getenv("POSTGRES_DB")
        port := os.Getenv("POSTGRES_PORT")
        dsn := fmt.Sprintf("user=%s password=%s host=%s database=%s port=%s sslmode=disable", user, password, host, database, port)
        db, err := sqlx.Connect("postgres", dsn)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>

        <span class="cov0" title="0">strcase.ConfigureAcronym("ID", "id")
        db.Mapper = reflectx.NewMapperFunc("json", strcase.ToSnake)
        dbs.SQL = db
        version, err := dbs.ping()
        if err == nil </span><span class="cov0" title="0">{
                log.Println("SQL version:", version)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package helper

import (
        "time"

        "github.com/golang/protobuf/ptypes"
        "github.com/golang/protobuf/ptypes/timestamp"
)

// DayDifference is a function to find day difference in time
func DayDifference(start time.Time, end time.Time) int <span class="cov0" title="0">{
        days := -start.YearDay()
        for year := start.Year(); year &lt; end.Year(); year++ </span><span class="cov0" title="0">{
                days += time.Date(year, time.December, 31, 0, 0, 0, 0, time.UTC).YearDay()
        }</span>
        <span class="cov0" title="0">days += end.YearDay()

        return days</span>
}

// TimeStampToText is a function to convert timestamp to text layout
func TimeStampToText(time *timestamp.Timestamp, layout string) string <span class="cov0" title="0">{
        timeDate, _ := ptypes.Timestamp(time)
        return timeDate.Format(layout)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
